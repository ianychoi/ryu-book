<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>링크 어그리게이션 &mdash; Ryubook 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="Ryubook 1.0 documentation" href="index.html" />
    <link rel="next" title="스패닝 트리" href="spanning_tree.html" />
    <link rel="prev" title="REST연계" href="rest_api.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="spanning_tree.html" title="스패닝 트리"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="rest_api.html" title="REST연계"
             accesskey="P">이전</a> |</li>
        <li><a href="index.html">Ryubook 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ch-link-aggregation">
<span id="id1"></span><h1>링크 어그리게이션<a class="headerlink" href="#ch-link-aggregation" title="제목 주소">¶</a></h1>
<p>이 장에서는 Ryu를 이용한 링크 어그리게이션 기능을 구현하는 방법을 설명하여 마련했습니다.</p>
<div class="section" id="id2">
<h2>링크 어그리게이션<a class="headerlink" href="#id2" title="제목 주소">¶</a></h2>
<p>링크 어그리게이션은 IEEE802.1AX-2008에서 규정 된 여러 물리적
회선을 묶어 하나의 논리적 링크로 처리 기술입니다. 링크 통합
기능은 특정 네트워크 장치 간의 통신 속도를 향상시킬 수 있으며 동시
에 중복성을 확보함으로써 감수성을 향상시킬 수 있습니다.</p>
<a class="reference internal image-reference" href="_images/fig13.png"><img alt="_images/fig13.png" class="align-center" src="_images/fig13.png" /></a>
<p>링크 통합 기능을 사용하려면 각 네트워크 장비에서
어떤 인터페이스를 어떤 그룹으로 묶을 것인가하는 설정을 미리 해두
해야합니다.</p>
<p>링크 통합 기능을 시작하는 방법에는 각각의 네트워크 장비에
대해 직접 지시 할 정적 방법과 LACP
(Link Aggregation Control Protocol)라는 프로토콜을 사용하여
으로 시작하는 역동적 인 방법이 있습니다.</p>
<p>역동적 인 방법을 채용 한 경우 각 네트워크 장비는 대향 인터페이스 동
선비에서 LACP 데이터 유닛을 정기적으로 교환하여 소통 불가능하지
것을 서로 확인하고 계속합니다. LACP 데이터 유닛 교환 단절 고장이
발생한 것으로 간주하고 해당 네트워크 장비는 사용 불가능 패킷 전송
수신은 나머지 인터페이스에 의해서만 이루어지게됩니다. 이 방법은
네트워크 장비간에 미디어 컨버터 등의 중계 장치가 존재하는 경우에도 중계
장치의 반대편 링크 다운을 감지 할 수 있다는 장점이 있습니다.
이 장에서는 LACP를 이용한 동적 링크 통합 기능을 처리 또는
입니다.</p>
</div>
<div class="section" id="ryu">
<h2>Ryu 응용 프로그램의 실행<a class="headerlink" href="#ryu" title="제목 주소">¶</a></h2>
<p>소스의 설명은 차후에 하고, 우선 Ryu의 링크 애그리 게이션 응용
프로그램을 실행 해 봅니다.</p>
<p>Ryu 소스 트리에 포함되어있는 simple_switch_lacp.py는 OpenFlow 1.0 전용
응용 프로그램이기 때문에 여기에서는 새롭게 OpenFlow 1.3에 대응 한
simple_switch_lacp_13.py을 만듭니다. 이 프로그램은
「 <a class="reference internal" href="switching_hub.html#ch-switching-hub"><em>스위칭 허브</em></a> 」스위칭 허브 링크 어 그리 게이션 기능을
추가 한 응용 프로그램입니다.</p>
<p>소스 이름： <tt class="docutils literal"><span class="pre">simple_switch_lacp_13.py</span></tt></p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ryu.base</span> <span class="kn">import</span> <span class="n">app_manager</span>
<span class="kn">from</span> <span class="nn">ryu.controller</span> <span class="kn">import</span> <span class="n">ofp_event</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">CONFIG_DISPATCHER</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">MAIN_DISPATCHER</span>
<span class="kn">from</span> <span class="nn">ryu.controller.handler</span> <span class="kn">import</span> <span class="n">set_ev_cls</span>
<span class="kn">from</span> <span class="nn">ryu.ofproto</span> <span class="kn">import</span> <span class="n">ofproto_v1_3</span>
<span class="kn">from</span> <span class="nn">ryu.lib</span> <span class="kn">import</span> <span class="n">lacplib</span>
<span class="kn">from</span> <span class="nn">ryu.lib.dpid</span> <span class="kn">import</span> <span class="n">str_to_dpid</span>
<span class="kn">from</span> <span class="nn">ryu.lib.packet</span> <span class="kn">import</span> <span class="n">packet</span>
<span class="kn">from</span> <span class="nn">ryu.lib.packet</span> <span class="kn">import</span> <span class="n">ethernet</span>


<span class="k">class</span> <span class="nc">SimpleSwitchLacp13</span><span class="p">(</span><span class="n">app_manager</span><span class="o">.</span><span class="n">RyuApp</span><span class="p">):</span>
    <span class="n">OFP_VERSIONS</span> <span class="o">=</span> <span class="p">[</span><span class="n">ofproto_v1_3</span><span class="o">.</span><span class="n">OFP_VERSION</span><span class="p">]</span>
    <span class="n">_CONTEXTS</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;lacplib&#39;</span><span class="p">:</span> <span class="n">lacplib</span><span class="o">.</span><span class="n">LacpLib</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimpleSwitchLacp13</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lacp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;lacplib&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lacp</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">dpid</span><span class="o">=</span><span class="n">str_to_dpid</span><span class="p">(</span><span class="s">&#39;0000000000000001&#39;</span><span class="p">),</span> <span class="n">ports</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPSwitchFeatures</span><span class="p">,</span> <span class="n">CONFIG_DISPATCHER</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">switch_features_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
        <span class="n">datapath</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
        <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>

        <span class="c"># install table-miss flow entry</span>
        <span class="c">#</span>
        <span class="c"># We specify NO BUFFER to max_len of the output action due to</span>
        <span class="c"># OVS bug. At this moment, if we specify a lesser number, e.g.,</span>
        <span class="c"># 128, OVS will send Packet-In with invalid buffer_id and</span>
        <span class="c"># truncated packet data. In that case, we cannot output packets</span>
        <span class="c"># correctly.</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">OFPMatch</span><span class="p">()</span>
        <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_CONTROLLER</span><span class="p">,</span>
                                          <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPCML_NO_BUFFER</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_flow</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">actions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">actions</span><span class="p">):</span>
        <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>

        <span class="n">inst</span> <span class="o">=</span> <span class="p">[</span><span class="n">parser</span><span class="o">.</span><span class="n">OFPInstructionActions</span><span class="p">(</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPIT_APPLY_ACTIONS</span><span class="p">,</span>
                                             <span class="n">actions</span><span class="p">)]</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">OFPFlowMod</span><span class="p">(</span><span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="n">priority</span><span class="p">,</span>
                                <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span> <span class="n">instructions</span><span class="o">=</span><span class="n">inst</span><span class="p">)</span>
        <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">del_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">OFPFlowMod</span><span class="p">(</span><span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span>
                                <span class="n">command</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFC_DELETE</span><span class="p">,</span>
                                <span class="n">out_port</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_ANY</span><span class="p">,</span>
                                <span class="n">out_group</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPG_ANY</span><span class="p">,</span>
                                <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">)</span>
        <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>

    <span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">lacplib</span><span class="o">.</span><span class="n">EventPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
        <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
        <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>
        <span class="n">in_port</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">match</span><span class="p">[</span><span class="s">&#39;in_port&#39;</span><span class="p">]</span>

        <span class="n">pkt</span> <span class="o">=</span> <span class="n">packet</span><span class="o">.</span><span class="n">Packet</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">eth</span> <span class="o">=</span> <span class="n">pkt</span><span class="o">.</span><span class="n">get_protocols</span><span class="p">(</span><span class="n">ethernet</span><span class="o">.</span><span class="n">ethernet</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">dst</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">dst</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">eth</span><span class="o">.</span><span class="n">src</span>

        <span class="n">dpid</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="p">{})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;packet in </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dpid</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">in_port</span><span class="p">)</span>

        <span class="c"># learn a mac address to avoid FLOOD next time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">][</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_port</span>

        <span class="k">if</span> <span class="n">dst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">]:</span>
            <span class="n">out_port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">][</span><span class="n">dst</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_port</span> <span class="o">=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_FLOOD</span>

        <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">out_port</span><span class="p">)]</span>

        <span class="c"># install a flow to avoid packet_in next time</span>
        <span class="k">if</span> <span class="n">out_port</span> <span class="o">!=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_FLOOD</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">OFPMatch</span><span class="p">(</span><span class="n">in_port</span><span class="o">=</span><span class="n">in_port</span><span class="p">,</span> <span class="n">eth_dst</span><span class="o">=</span><span class="n">dst</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_flow</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">actions</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span> <span class="o">==</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_NO_BUFFER</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">data</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">OFPPacketOut</span><span class="p">(</span><span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">buffer_id</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">buffer_id</span><span class="p">,</span>
                                  <span class="n">in_port</span><span class="o">=</span><span class="n">in_port</span><span class="p">,</span> <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">lacplib</span><span class="o">.</span><span class="n">EventSlaveStateChanged</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_slave_state_changed_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
        <span class="n">datapath</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">datapath</span>
        <span class="n">dpid</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">id</span>
        <span class="n">port_no</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">port</span>
        <span class="n">enabled</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">enabled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;slave state changed port: </span><span class="si">%d</span><span class="s"> enabled: </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span>
                         <span class="n">port_no</span><span class="p">,</span> <span class="n">enabled</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dpid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">mac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">]:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPMatch</span><span class="p">(</span><span class="n">eth_dst</span><span class="o">=</span><span class="n">mac</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">del_flow</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="p">{})</span>
</pre></div>
</div>
<div class="section" id="id3">
<h3>실험 환경 구축<a class="headerlink" href="#id3" title="제목 주소">¶</a></h3>
<p>OpenFlow 스위치 및 Linux 호스트 사이에서 링크 통합을 구성하여 봅시다.</p>
<p>VM 이미지 사용을위한 환경 설정 및 로그인 방법 등은 「 <a class="reference internal" href="switching_hub.html#ch-switching-hub"><em>스위칭 허브</em></a> 」
을 참조하십시오.</p>
<p>먼저 Mininet를 이용하여 아래 그림과 같은 토폴로지를 만듭니다.</p>
<a class="reference internal image-reference" href="_images/fig21.png"><img alt="_images/fig21.png" class="align-center" src="_images/fig21.png" /></a>
<p>Mininet API를 호출하는 스크립트를 작성하고 필요한 토폴로지를 구축
합니다.</p>
<p>소스 이름： <tt class="docutils literal"><span class="pre">link_aggregation.py</span></tt></p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>

<span class="kn">from</span> <span class="nn">mininet.cli</span> <span class="kn">import</span> <span class="n">CLI</span>
<span class="kn">from</span> <span class="nn">mininet.link</span> <span class="kn">import</span> <span class="n">Link</span>
<span class="kn">from</span> <span class="nn">mininet.net</span> <span class="kn">import</span> <span class="n">Mininet</span>
<span class="kn">from</span> <span class="nn">mininet.node</span> <span class="kn">import</span> <span class="n">RemoteController</span>
<span class="kn">from</span> <span class="nn">mininet.term</span> <span class="kn">import</span> <span class="n">makeTerm</span>

<span class="k">if</span> <span class="s">&#39;__main__&#39;</span> <span class="o">==</span> <span class="n">__name__</span><span class="p">:</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">Mininet</span><span class="p">(</span><span class="n">controller</span><span class="o">=</span><span class="n">RemoteController</span><span class="p">)</span>

    <span class="n">c0</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">addController</span><span class="p">(</span><span class="s">&#39;c0&#39;</span><span class="p">)</span>

    <span class="n">s1</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">addSwitch</span><span class="p">(</span><span class="s">&#39;s1&#39;</span><span class="p">)</span>

    <span class="n">h1</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">addHost</span><span class="p">(</span><span class="s">&#39;h1&#39;</span><span class="p">)</span>
    <span class="n">h2</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">addHost</span><span class="p">(</span><span class="s">&#39;h2&#39;</span><span class="p">,</span> <span class="n">mac</span><span class="o">=</span><span class="s">&#39;00:00:00:00:00:22&#39;</span><span class="p">)</span>
    <span class="n">h3</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">addHost</span><span class="p">(</span><span class="s">&#39;h3&#39;</span><span class="p">,</span> <span class="n">mac</span><span class="o">=</span><span class="s">&#39;00:00:00:00:00:23&#39;</span><span class="p">)</span>
    <span class="n">h4</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">addHost</span><span class="p">(</span><span class="s">&#39;h4&#39;</span><span class="p">,</span> <span class="n">mac</span><span class="o">=</span><span class="s">&#39;00:00:00:00:00:24&#39;</span><span class="p">)</span>

    <span class="n">Link</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">h1</span><span class="p">)</span>
    <span class="n">Link</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">h1</span><span class="p">)</span>
    <span class="n">Link</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">h2</span><span class="p">)</span>
    <span class="n">Link</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">h3</span><span class="p">)</span>
    <span class="n">Link</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">h4</span><span class="p">)</span>

    <span class="n">net</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
    <span class="n">c0</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">s1</span><span class="o">.</span><span class="n">start</span><span class="p">([</span><span class="n">c0</span><span class="p">])</span>

    <span class="n">net</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">makeTerm</span><span class="p">(</span><span class="n">c0</span><span class="p">))</span>
    <span class="n">net</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">makeTerm</span><span class="p">(</span><span class="n">s1</span><span class="p">))</span>
    <span class="n">net</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">makeTerm</span><span class="p">(</span><span class="n">h1</span><span class="p">))</span>
    <span class="n">net</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">makeTerm</span><span class="p">(</span><span class="n">h2</span><span class="p">))</span>
    <span class="n">net</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">makeTerm</span><span class="p">(</span><span class="n">h3</span><span class="p">))</span>
    <span class="n">net</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">makeTerm</span><span class="p">(</span><span class="n">h4</span><span class="p">))</span>

    <span class="n">CLI</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>

    <span class="n">net</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p>이 스크립트를 실행하여 호스트 h1과 스위치 s1 사이에 2 개의 링크가
존재하는 토폴로지가됩니다. net 명령으로 생성 된 토폴로지를 확인해야
할 수 있습니다.</p>
<div class="console highlight-python"><div class="highlight"><pre>ryu@ryu-vm:~$ sudo ./link_aggregation.py
Unable to contact the remote controller at 127.0.0.1:6633
mininet&gt; net
c0
s1 lo:  s1-eth1:h1-eth0 s1-eth2:h1-eth1 s1-eth3:h2-eth0 s1-eth4:h3-eth0 s1-eth5:h4-eth0
h1 h1-eth0:s1-eth1 h1-eth1:s1-eth2
h2 h2-eth0:s1-eth3
h3 h3-eth0:s1-eth4
h4 h4-eth0:s1-eth5
mininet&gt;
</pre></div>
</div>
</div>
<div class="section" id="h1">
<h3>호스트 h1에서 링크 통합 구성<a class="headerlink" href="#h1" title="제목 주소">¶</a></h3>
<p>호스트 h1의 Linux에 필요한 사전 설정을 실시합시다.
절
에서 명령 입력 호스트 h1의 xterm에서 실시해주세요.</p>
<p>먼저 링크 통합을위한 드라이버 모듈을로드합니다.
Linux에서는 링크 통합 기능을 결합 드라이버가 담당하고 있습니다.
미리 드라이버의 설정 파일을 /etc/modprobe.d/bonding.conf로 작성 해
수 있습니다.</p>
<p>파일 이름: <tt class="docutils literal"><span class="pre">/etc/modprobe.d/bonding.conf</span></tt></p>
<div class="sourcecode highlight-python"><div class="highlight"><pre>alias bond0 bonding
options bonding mode=4
</pre></div>
</div>
<p>Node: h1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# modprobe bonding
</pre></div>
</div>
<p>mode = 4는 LACP를 이용한 동적 링크 통합 할 것을 나타냄
입니다. 기본값이기 때문에 여기에서 설정을 선택하고 있습니다 만, LACP 데이터 유닛
교환주기는 SLOW (30 초 간격) 배분 논리는 목적지 MAC 주소를 기반으로 할거야
게 설정되어 있습니다.</p>
<p>이어 bond0이라는 논리 인터페이스를 새로 만듭니다. 또한 bond0
MAC 주소로 적당한 값을 설정합니다.</p>
<p>Node: h1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ip link add bond0 type bond
root@ryu-vm:~# ip link set bond0 address 02:01:02:03:04:08
</pre></div>
</div>
<p>만든 논리 인터페이스의 그룹에 h1-eth0와 h1-eth1의 물리적 인터
페이스를 참여시킵니다. 이 때, 물리적 인터페이스를 다운시켜 둘 필요
수 있습니다. 또한 무작위로 결정되는 물리적 인터페이스의 MAC 주소를
알기 쉬운 값으로 갱신해야합니다.</p>
<p>Node: h1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ip link set h1-eth0 down
root@ryu-vm:~# ip link set h1-eth0 address 00:00:00:00:00:11
root@ryu-vm:~# ip link set h1-eth0 master bond0
root@ryu-vm:~# ip link set h1-eth1 down
root@ryu-vm:~# ip link set h1-eth1 address 00:00:00:00:00:12
root@ryu-vm:~# ip link set h1-eth1 master bond0
</pre></div>
</div>
<p>논리 인터페이스에 IP 주소를 할당합니다.
여기에 10.0.0.1를 할당합니다. 또한 h1-eth0에 IP 주소
이 할당되어 있으므로 이를 제거합니다.</p>
<p>Node: h1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ip addr add 10.0.0.1/8 dev bond0
root@ryu-vm:~# ip addr del 10.0.0.1/8 dev h1-eth0
</pre></div>
</div>
<p>마지막으로, 논리적 인터페이스를 향상시킵니다.</p>
<p>Node: h1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ip link set bond0 up
</pre></div>
</div>
<p>여기에서 각 인터페이스의 상태를 확인해야합니다.</p>
<p>Node: h1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ifconfig
bond0     Link encap:Ethernet  HWaddr 02:01:02:03:04:08
          inet addr:10.0.0.1  Bcast:0.0.0.0  Mask:255.0.0.0
          UP BROADCAST RUNNING MASTER MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:10 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:1240 (1.2 KB)

h1-eth0   Link encap:Ethernet  HWaddr 02:01:02:03:04:08
          UP BROADCAST RUNNING SLAVE MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:620 (620.0 B)

h1-eth1   Link encap:Ethernet  HWaddr 02:01:02:03:04:08
          UP BROADCAST RUNNING SLAVE MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:620 (620.0 B)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</pre></div>
</div>
<p>논리적 인터페이스 bond0가 MASTER 물리 인터페이스 h1-eth0와 h1-eth1이
SLAVE되어있는 것을 알 수 있습니다. 또한 bond0, h1-eth0, h1-eth1의 MAC 주소
스가 모두 동일하게되어있는 것을 알 수 있습니다.</p>
<p>본딩 드라이버의 상태도 확인해야합니다.</p>
<p>Node: h1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# cat /proc/net/bonding/bond0
Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)

Bonding Mode: IEEE 802.3ad Dynamic link aggregation
Transmit Hash Policy: layer2 (0)
MII Status: up
MII Polling Interval (ms): 100
Up Delay (ms): 0
Down Delay (ms): 0

802.3ad info
LACP rate: slow
Min links: 0
Aggregator selection policy (ad_select): stable
Active Aggregator Info:
        Aggregator ID: 1
        Number of ports: 1
        Actor Key: 33
        Partner Key: 1
        Partner Mac Address: 00:00:00:00:00:00

Slave Interface: h1-eth0
MII Status: up
Speed: 10000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:00:00:00:00:11
Aggregator ID: 1
Slave queue ID: 0

Slave Interface: h1-eth1
MII Status: up
Speed: 10000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:00:00:00:00:12
Aggregator ID: 2
Slave queue ID: 0
</pre></div>
</div>
<p>LACP 데이터 유닛의 교환주기 (LACP rate : slow)와 배분 로직 설정
(Transmit Hash Policy : layer2 (0))를 확인할 수 있습니다. 또한 물리적 인터
페이스 h1-eth0와 h1-eth1의 MAC 주소를 확인할 수 있습니다.</p>
<p>이상으로 호스트 h1의 사전 설정이 완료됩니다.</p>
</div>
<div class="section" id="openflow">
<h3>OpenFlow 버전 설정<a class="headerlink" href="#openflow" title="제목 주소">¶</a></h3>
<p>스위치 s1의 OpenFlow의
버전을 1.3으로 설정합니다. 이 명령 입력 스위치 s1의 xterm에서 실시
하십시오.</p>
<p>Node: s1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ovs-vsctl set Bridge s1 protocols=OpenFlow13
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>스위칭 허브의 실행<a class="headerlink" href="#id4" title="제목 주소">¶</a></h3>
<p>준비가 그래서 처음에 만든 Ryu 응용 프로그램을 실행합니다.</p>
<p>윈도우 제목이 「Node: c0 (root)」이다 xterm에서 다음 명령
을 실행합니다.</p>
<p>Node: c0:</p>
<div class="console highlight-python"><div class="highlight"><pre>ryu@ryu-vm:~$ ryu-manager ./simple_switch_lacp_13.py
loading app ./simple_switch_lacp_13.py
loading app ryu.controller.ofp_handler
creating context lacplib
instantiating app ./simple_switch_lacp_13.py
instantiating app ryu.controller.ofp_handler
...
</pre></div>
</div>
<p>호스트 h1은 30 초에 한 번 LACP 데이터 단위를 전송합니다. 시작에서 시바
낙서하면 스위치는 호스트 h1에서 LACP 데이터 단위를 수신하여 작동 로그에
출력합니다.</p>
<p>Node: c0:</p>
<div class="console highlight-python"><div class="highlight"><pre>...
[LACP][INFO] SW=0000000000000001 PORT=1 LACP received.
[LACP][INFO] SW=0000000000000001 PORT=1 the slave i/f has just been up.
[LACP][INFO] SW=0000000000000001 PORT=1 the timeout time has changed.
[LACP][INFO] SW=0000000000000001 PORT=1 LACP sent.
slave state changed port: 1 enabled: True
[LACP][INFO] SW=0000000000000001 PORT=2 LACP received.
[LACP][INFO] SW=0000000000000001 PORT=2 the slave i/f has just been up.
[LACP][INFO] SW=0000000000000001 PORT=2 the timeout time has changed.
[LACP][INFO] SW=0000000000000001 PORT=2 LACP sent.
slave state changed port: 2 enabled: True
...
</pre></div>
</div>
<p>로그는 다음을 나타냅니다.</p>
<ul>
<li><p class="first">LACP received.</p>
<blockquote>
<div><p>LACP 데이터 단위를 수신했습니다.</p>
</div></blockquote>
</li>
<li><p class="first">the slave i/f has just been up.</p>
<blockquote>
<div><p>비활성화 상태였던 포트가 활성화 상태로 변경되었습니다.</p>
</div></blockquote>
</li>
<li><p class="first">the timeout time has changed.</p>
<blockquote>
<div><p>LACP 데이터 단위 무선 통신 감시 시간이 변경되었습니다 (이번 경우 초기 상태
0 초에서 LONG_TIMEOUT_TIME 90 초로 변경됩니다).</p>
</div></blockquote>
</li>
<li><p class="first">LACP sent.</p>
<blockquote>
<div><p>응답에 대한 LACP 데이터 단위를 전송했습니다.</p>
</div></blockquote>
</li>
<li><p class="first">slave state changed ...</p>
<blockquote>
<div><p>LACP 도서관에서 `` EventSlaveStateChanged `` 이벤트를 응용
프로그램이 수신되었습니다 (이벤트의 자세한 내용은 아래 참조).</p>
</div></blockquote>
</li>
</ul>
<p>스위치는 호스트 h1에서 LACP 데이터 유닛을 수신 할 때마다 응답 용 LACP 데이터 단위 전송
신합니다.</p>
<p>Node: c0:</p>
<div class="console highlight-python"><div class="highlight"><pre>...
[LACP][INFO] SW=0000000000000001 PORT=1 LACP received.
[LACP][INFO] SW=0000000000000001 PORT=1 LACP sent.
[LACP][INFO] SW=0000000000000001 PORT=2 LACP received.
[LACP][INFO] SW=0000000000000001 PORT=2 LACP sent.
...
</pre></div>
</div>
<p>흐름 항목을 확인하여 봅시다.</p>
<p>Node: s1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ovs-ofctl -O openflow13 dump-flows s1
OFPST_FLOW reply (OF1.3) (xid=0x2):
 cookie=0x0, duration=14.565s, table=0, n_packets=1, n_bytes=124, idle_timeout=90, send_flow_rem priority=65535,in_port=2,dl_src=00:00:00:00:00:12,dl_type=0x8809 actions=CONTROLLER:65509
 cookie=0x0, duration=14.562s, table=0, n_packets=1, n_bytes=124, idle_timeout=90, send_flow_rem priority=65535,in_port=1,dl_src=00:00:00:00:00:11,dl_type=0x8809 actions=CONTROLLER:65509
 cookie=0x0, duration=24.821s, table=0, n_packets=2, n_bytes=248, priority=0 actions=CONTROLLER:65535
</pre></div>
</div>
<p>스위치는</p>
<ul class="simple">
<li>h1의 h1-eth1 (입력 포트가 s1-eth2에서 MAC 주소가 00:00:00:00:00:12)에서
LACP 데이터 유닛 (ethertype가 0x8809)가 보내져 오면 Packet-In 메시지
를 보냄</li>
<li>h1의 h1-eth0 (입력 포트가 s1-eth1에서 MAC 주소가 00:00:00:00:00:11)에서
LACP 데이터 유닛 (ethertype가 0x8809)가 보내져 오면 Packet-In 메시지
를 보냄</li>
<li>「 <a class="reference internal" href="switching_hub.html#ch-switching-hub"><em>스위칭 허브</em></a> 」와 같은 Table-miss 흐름 항목</li>
</ul>
<p>세 가지 흐름 항목이 등록되어 있습니다.</p>
</div>
<div class="section" id="id5">
<h3>링크 통합 기능 확인<a class="headerlink" href="#id5" title="제목 주소">¶</a></h3>
<div class="section" id="id6">
<h4>통신 속도 향상<a class="headerlink" href="#id6" title="제목 주소">¶</a></h4>
<p>우선 링크 통합에 의한 통신 속도의 향상을 확인합니다.
통신에 따라 여러 링크를 구사하는 모습을보고하자.</p>
<p>먼저 호스트 h2에서 호스트 h1 대해 ping을 실행합니다.</p>
<p>Node: h2:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ping 10.0.0.1
PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
64 bytes from 10.0.0.1: icmp_req=1 ttl=64 time=93.0 ms
64 bytes from 10.0.0.1: icmp_req=2 ttl=64 time=0.266 ms
64 bytes from 10.0.0.1: icmp_req=3 ttl=64 time=0.075 ms
64 bytes from 10.0.0.1: icmp_req=4 ttl=64 time=0.065 ms
...
</pre></div>
</div>
<p>ping을 계속 채 스위치 s1의 흐름 항목을 확인합니다.</p>
<p>Node: s1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ovs-ofctl -O openflow13 dump-flows s1
OFPST_FLOW reply (OF1.3) (xid=0x2):
 cookie=0x0, duration=22.05s, table=0, n_packets=1, n_bytes=124, idle_timeout=90, send_flow_rem priority=65535,in_port=2,dl_src=00:00:00:00:00:12,dl_type=0x8809 actions=CONTROLLER:65509
 cookie=0x0, duration=22.046s, table=0, n_packets=1, n_bytes=124, idle_timeout=90, send_flow_rem priority=65535,in_port=1,dl_src=00:00:00:00:00:11,dl_type=0x8809 actions=CONTROLLER:65509
 cookie=0x0, duration=33.046s, table=0, n_packets=6, n_bytes=472, priority=0 actions=CONTROLLER:65535
 cookie=0x0, duration=3.259s, table=0, n_packets=3, n_bytes=294, priority=1,in_port=3,dl_dst=02:01:02:03:04:08 actions=output:1
 cookie=0x0, duration=3.262s, table=0, n_packets=4, n_bytes=392, priority=1,in_port=1,dl_dst=00:00:00:00:00:22 actions=output:3
</pre></div>
</div>
<p>방금 확인한 시점에서 두 흐름 항목이 추가되어 있습니다.
duration 값이 작은 4 번째와 5 번째 항목입니다.</p>
<p>각각</p>
<ul class="simple">
<li>3 번 포트 (s1-eth3, 즉 h2 대향 인터페이스)에서 h1의 bond0에게의 파
패킷을 수신하면 1 번 포트 (s1-eth1)에서 출력</li>
<li>1 번 포트 (s1-eth1)에서 h2에게 패킷을 받으면 3 번 포트 (s1-eth3)에서
출력하기</li>
</ul>
<p>라는 흐름 항목입니다. h2와 h1 사이의 통신에는 s1-eth1이 사용 된 것을 알 수
있습니다.</p>
<p>그런 다음 호스트 h3에서 호스트 h1 대해 ping을 실행합니다.</p>
<p>Node: h3:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ping 10.0.0.1
PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
64 bytes from 10.0.0.1: icmp_req=1 ttl=64 time=91.2 ms
64 bytes from 10.0.0.1: icmp_req=2 ttl=64 time=0.256 ms
64 bytes from 10.0.0.1: icmp_req=3 ttl=64 time=0.057 ms
64 bytes from 10.0.0.1: icmp_req=4 ttl=64 time=0.073 ms
...
</pre></div>
</div>
<p>ping을 계속 채 스위치 s1의 흐름 항목을 확인합니다.</p>
<p>Node: s1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ovs-ofctl -O openflow13 dump-flows s1
OFPST_FLOW reply (OF1.3) (xid=0x2):
 cookie=0x0, duration=99.765s, table=0, n_packets=4, n_bytes=496, idle_timeout=90, send_flow_rem priority=65535,in_port=2,dl_src=00:00:00:00:00:12,dl_type=0x8809 actions=CONTROLLER:65509
 cookie=0x0, duration=99.761s, table=0, n_packets=4, n_bytes=496, idle_timeout=90, send_flow_rem priority=65535,in_port=1,dl_src=00:00:00:00:00:11,dl_type=0x8809 actions=CONTROLLER:65509
 cookie=0x0, duration=110.761s, table=0, n_packets=10, n_bytes=696, priority=0 actions=CONTROLLER:65535
 cookie=0x0, duration=80.974s, table=0, n_packets=82, n_bytes=7924, priority=1,in_port=3,dl_dst=02:01:02:03:04:08 actions=output:1
 cookie=0x0, duration=2.677s, table=0, n_packets=2, n_bytes=196, priority=1,in_port=2,dl_dst=00:00:00:00:00:23 actions=output:4
 cookie=0x0, duration=2.675s, table=0, n_packets=1, n_bytes=98, priority=1,in_port=4,dl_dst=02:01:02:03:04:08 actions=output:2
 cookie=0x0, duration=80.977s, table=0, n_packets=83, n_bytes=8022, priority=1,in_port=1,dl_dst=00:00:00:00:00:22 actions=output:3
</pre></div>
</div>
<p>방금 확인한 시점에서 두 흐름 항목이 추가되어 있습니다.
duration 값이 작은 다섯 번째와 여섯 번째 항목입니다.</p>
<p>각각</p>
<ul class="simple">
<li>2 번 포트 (s1-eth2)에서 h3에게 패킷을 수신하면 4 번 포트 (s1-eth4)에서
출력하기</li>
<li>4 번 포트 (s1-eth4 즉 h3의 대향 인터페이스)에서 h1의 bond0에게의 파
패킷을 수신하면 2 번 포트 (s1-eth2)에서 출력</li>
</ul>
<p>라는 흐름 항목입니다. h3와 h1 사이의 통신에는 s1-eth2가 사용 된 것을 알 수
있습니다.</p>
<p>물론 호스트 h4에서 호스트 h1로도 ping을 수행 할 수 있습니다.
지금까지와 마찬가지로 새로운 흐름 항목이 등록되어
h4와 h1 사이의 통신에는 s1-eth1이 사용됩니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">대상 호스트</th>
<th class="head">사용 포트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>h2</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>h3</td>
<td>2</td>
</tr>
<tr class="row-even"><td>h4</td>
<td>1</td>
</tr>
</tbody>
</table>
<a class="reference internal image-reference" href="_images/fig31.png"><img alt="_images/fig31.png" class="align-center" src="_images/fig31.png" /></a>
<p>이상과 같이 통신에 따라 여러 링크를 구사하는 모습을 확인할 수 있었습니다.</p>
</div>
<div class="section" id="id7">
<h4>결함 허용 향상<a class="headerlink" href="#id7" title="제목 주소">¶</a></h4>
<p>다음 링크 통합에 의한 감수성 향상을 확인합니다. 현재 상황은
h2와 h4가 h1와 통신 할 때 s1-eth2를 h3이 h1와 통신 할 때 s1-eth1을 사용하여
있습니다.</p>
<p>여기서 s1-eth1의 대향 인터페이스이다 h1-eth0를 링크 통합
그룹에서 이탈시킵니다.</p>
<p>Node: h1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ip link set h1-eth0 nomaster
</pre></div>
</div>
<p>h1-eth0가 중지함으로써 호스트 h3에서 호스트 h1에 ping이 소통 불가능
있습니다. 무 통신 감시 시간 90 초가 경과하면 컨트롤러의 동작
로그에 다음과 같은 메시지가 출력됩니다.</p>
<p>Node: c0:</p>
<div class="console highlight-python"><div class="highlight"><pre>...
[LACP][INFO] SW=0000000000000001 PORT=1 LACP received.
[LACP][INFO] SW=0000000000000001 PORT=1 LACP sent.
[LACP][INFO] SW=0000000000000001 PORT=2 LACP received.
[LACP][INFO] SW=0000000000000001 PORT=2 LACP sent.
[LACP][INFO] SW=0000000000000001 PORT=2 LACP received.
[LACP][INFO] SW=0000000000000001 PORT=2 LACP sent.
[LACP][INFO] SW=0000000000000001 PORT=2 LACP received.
[LACP][INFO] SW=0000000000000001 PORT=2 LACP sent.
[LACP][INFO] SW=0000000000000001 PORT=1 LACP exchange timeout has occurred.
slave state changed port: 1 enabled: False
...
</pre></div>
</div>
<p>「LACP exchange timeout has occurred.」무 통신 감시 시간에 도달
것을 나타냅니다.
여기에서는 학습 한
MAC 주소 전송의 흐름 항목을 삭제하는 것으로,
스위치를 시작한 직후의 상태로 되돌립니다.</p>
<p>새로운 통신이 발생하면 새로운 MAC 주소를 학습하고
살아있는 링크만을 이용한 흐름 항목이 다시 등록됩니다.</p>
<p>호스트 h3와 호스트 h1 사이도 새로운 흐름 항목이 등록되어</p>
<p>Node: s1:</p>
<div class="console highlight-python"><div class="highlight"><pre>root@ryu-vm:~# ovs-ofctl -O openflow13 dump-flows s1
OFPST_FLOW reply (OF1.3) (xid=0x2):
 cookie=0x0, duration=364.265s, table=0, n_packets=13, n_bytes=1612, idle_timeout=90, send_flow_rem priority=65535,in_port=2,dl_src=00:00:00:00:00:12,dl_type=0x8809 actions=CONTROLLER:65509
 cookie=0x0, duration=374.521s, table=0, n_packets=25, n_bytes=1830, priority=0 actions=CONTROLLER:65535
 cookie=0x0, duration=5.738s, table=0, n_packets=5, n_bytes=490, priority=1,in_port=3,dl_dst=02:01:02:03:04:08 actions=output:2
 cookie=0x0, duration=6.279s, table=0, n_packets=5, n_bytes=490, priority=1,in_port=2,dl_dst=00:00:00:00:00:23 actions=output:5
 cookie=0x0, duration=6.281s, table=0, n_packets=5, n_bytes=490, priority=1,in_port=5,dl_dst=02:01:02:03:04:08 actions=output:2
 cookie=0x0, duration=5.506s, table=0, n_packets=5, n_bytes=434, priority=1,in_port=4,dl_dst=02:01:02:03:04:08 actions=output:2
 cookie=0x0, duration=5.736s, table=0, n_packets=5, n_bytes=490, priority=1,in_port=2,dl_dst=00:00:00:00:00:21 actions=output:3
 cookie=0x0, duration=6.504s, table=0, n_packets=6, n_bytes=532, priority=1,in_port=2,dl_dst=00:00:00:00:00:22 actions=output:4
</pre></div>
</div>
<p>호스트 h3 중지했다 ping이 다시 시작합니다.</p>
<p>Node: h3:</p>
<div class="console highlight-python"><div class="highlight"><pre>...
64 bytes from 10.0.0.1: icmp_req=144 ttl=64 time=0.193 ms
64 bytes from 10.0.0.1: icmp_req=145 ttl=64 time=0.081 ms
64 bytes from 10.0.0.1: icmp_req=146 ttl=64 time=0.095 ms
64 bytes from 10.0.0.1: icmp_req=237 ttl=64 time=44.1 ms
64 bytes from 10.0.0.1: icmp_req=238 ttl=64 time=2.52 ms
64 bytes from 10.0.0.1: icmp_req=239 ttl=64 time=0.371 ms
64 bytes from 10.0.0.1: icmp_req=240 ttl=64 time=0.103 ms
64 bytes from 10.0.0.1: icmp_req=241 ttl=64 time=0.067 ms
...
</pre></div>
</div>
<p>이상과 같이 일부 링크에 고장이 발생한 경우에도 다른 링크
를 사용하여 자동으로 복구 할 수 있는지 확인 할 수있었습니다.</p>
</div>
</div>
</div>
<div class="section" id="id8">
<h2>Ryu의 링크 애그리 게이션 기능의 구현<a class="headerlink" href="#id8" title="제목 주소">¶</a></h2>
<p>OpenFlow를 이용한있어 등
같이 링크 통합 기능을 제공하는지 알아 보겠습니다.</p>
<p>LACP를 이용한 링크 어 그리 게이션은 「LACP 데이터 유닛의 교환이 성공적으로 이루어지고있는 동안은 해당 물리적 인터페이스는 사용」「LACP
데이터 유닛의 교환이 두절되면 해당 물리적 인터페이스는 무효 」라고 거절 무용
입니다. 물리적 인터페이스를 비활성화하는 것은, 그 인터페이스를 사용
용하는 흐름 항목이 존재하지 않는다는 것도 있습니다. 따라서,</p>
<ul class="simple">
<li>LACP 데이터 단위를 수신하면 응답을 작성하여 보냄</li>
<li>LACP 데이터 단위가 일정 시간 수신 할 수없는 경우 해당 물리적 인터페이스를
사용 흐름 항목을 삭제하고 이후 그 인터페이스를 사용하는 흐름
항목을 등록</li>
<li>무효가 된 물리적 인터페이스에서 LACP 데이터 유닛을받은 경우 당해
인터페이스를 다시 활성화</li>
<li>LACP 데이터 단위 이외의 패킷은 「 <a class="reference internal" href="switching_hub.html#ch-switching-hub"><em>스위칭 허브</em></a> 」처럼
학습 · 전송</li>
</ul>
<p>하는 처리를 구현하면 링크 통합의 기본 동작이 가능해 또는
입니다. LACP에 관련되는 부분과 그렇지 않은 부분이 명확하게 나뉘어 있기 때문에 LACP에 관한
부분을 LACP 라이브러리로 잘라, 그렇지 않은 부분은
「 <a class="reference internal" href="switching_hub.html#ch-switching-hub"><em>스위칭 허브</em></a> 」스위칭 허브를 확장하는 형태로 구현합니다
입니다.</p>
<p>LACP 데이터 유닛 수신시 응답 작성 · 전송 흐름 항목만으로는 실현 불가능
이기 때문에 Packet-In 메시지를 사용하여 OpenFlow 컨트롤러에서 처리를 수행
있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>LACP 데이터 유닛을 교체하려는 물리 인터페이스는 그 역할에 따라
ACTIVE와 PASSIVE로 분류됩니다. ACTIVE는 일정 시간마다 LACP 데이터 유닛
를 보내고 소통을 능동적으로 확인합니다. PASSIVE는 ACTIVE에서 전송 된 LACP
데이터 단위를 수신했을 때 응답을 반환하여 소통을 수동적으로 확인합니다.</p>
<p class="last">Ryu 링크 어 그리 게이션 애플리케이션은 PASSIVE 모드 만 실
이렇게하고 있습니다.</p>
</div>
<p>일정 시간 LACP 데이터 단위를받지 못한 경우 해당 물리적 인터페이스를
해제한다는 처리는 LACP 데이터 단위 Packet-In시키는 흐름 항목
에 idle_timeout을 설정하고 만료시 FlowRemoved 메시지를 보내도록 할
하여 OpenFlow 컨트롤러에서 해당 인터페이스를 사용할 때의 대처를
할 수 있습니다.</p>
<p>비활성화 된 인터페이스에서 LACP 데이터 유닛의 교환이 재개 된 경우의 처리
는 LACP 데이터 유닛 수신시의 Packet-In 메시지 처리기에서 해당 인터
페이스의 활성화 / 비활성화 상태를 확인 · 수정하여 제공합니다.</p>
<p>물리적 인터페이스가 무효가되었을 때, OpenFlow 컨트롤러의 처리로
&#8220;해당 인터페이스를 사용하는 흐름 항목 삭제&#8221;뿐만 좋을 듯 보
네 합니다만, 그러면 충분하지 않습니다.</p>
<p>예를 들어 3 개의 물리적 인터페이스를 그룹화하여 사용하는 논리적 인터
페이스가 있고 배분 논리가 &#8220;효과적인 인터페이스 수에 의한 MAC 주소
스 나머지 &#8220;라고되어있는 경우를 가정합니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="34%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">인터페이스1</th>
<th class="head">인터페이스2</th>
<th class="head">인터페이스3</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>MAC 주소의 나머지:0</td>
<td>MAC 주소의 나머지:1</td>
<td>MAC 주소의 나머지:2</td>
</tr>
</tbody>
</table>
<p>그리고 각 물리적 인터페이스를 사용하는 흐름 항목이 다음과 같이 3 개씩
등록되어 있었다고합니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="34%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">인터페이스1</th>
<th class="head">인터페이스2</th>
<th class="head">인터페이스3</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>주소:00:00:00:00:00:00</td>
<td>주소:00:00:00:00:00:01</td>
<td>주소:00:00:00:00:00:02</td>
</tr>
<tr class="row-odd"><td>주소:00:00:00:00:00:03</td>
<td>주소:00:00:00:00:00:04</td>
<td>주소:00:00:00:00:00:05</td>
</tr>
<tr class="row-even"><td>주소:00:00:00:00:00:06</td>
<td>주소:00:00:00:00:00:07</td>
<td>주소:00:00:00:00:00:08</td>
</tr>
</tbody>
</table>
<p>여기서 인터페이스 1가 비활성화 된 경우 「효과적인 인터페이스 수에 의한
MAC 주소의 나머지」라는 배분 논리에 따라 다음과 같이 분류 수없는
하여야합니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="34%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">인터페이스1</th>
<th class="head">인터페이스2</th>
<th class="head">인터페이스3</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>비활성화</td>
<td>MAC 주소의 나머지:0</td>
<td>MAC 주소의 나머지:1</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="34%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">인터페이스1</th>
<th class="head">인터페이스2</th>
<th class="head">인터페이스3</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td></td>
<td>주소:00:00:00:00:00:00</td>
<td>주소:00:00:00:00:00:01</td>
</tr>
<tr class="row-odd"><td></td>
<td>주소:00:00:00:00:00:02</td>
<td>주소:00:00:00:00:00:03</td>
</tr>
<tr class="row-even"><td></td>
<td>주소:00:00:00:00:00:04</td>
<td>주소:00:00:00:00:00:05</td>
</tr>
<tr class="row-odd"><td></td>
<td>주소:00:00:00:00:00:06</td>
<td>주소:00:00:00:00:00:07</td>
</tr>
<tr class="row-even"><td></td>
<td>주소:00:00:00:00:00:08</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>인터페이스 1을 사용하고 있었다 흐름 항목뿐만 아니라 인터페이스 2 또는
인터페이스 3의 흐름 항목도 다시 작성해야 볼 수 있습니다. 이것은
물리적 인터페이스를 사용할 때뿐만 아니라 활성화되었을 때도 마찬가지
입니다.</p>
<p>따라서, 물리적 인터페이스의 활성화 / 비활성화 상태가 변경되었을 경우의 처리는 당해
물리적 인터페이스가 속한 논리 인터페이스에 포함 된 모든 물리적 인
페이스를 사용하는 흐름 항목을 삭제한다고합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">배분 논리에 대해서는 사양으로 정해져 있지 않고, 각 기기의 구현에 맡길 수
있습니다. Ryu 링크 어 그리 게이션 애플리케이션은 자신의 모습
분할 처리를하지 않고 대향 장치에 의해 배분 된 경로를 사용하고 있습니다
입니다.</p>
</div>
<p>여기에는 다음과 같은 기능을 구현합니다.</p>
<p><strong>LACP 라이브러리</strong></p>
<ul class="simple">
<li>LACP 데이터 단위를 수신하면 응답을 작성하여 보냄</li>
<li>LACP 데이터 유닛의 수신이 두절되면 해당 물리적 인터페이스를 무효로 간주,
스위칭 허브에 통지한다</li>
<li>LACP 데이터 유닛의 수신이 재개되면 대응하는 물리
인터페이스를 유효한 것으로 간주 스위칭 허브에 통지한다</li>
</ul>
<p><strong>스위칭 허브</strong></p>
<ul class="simple">
<li>LACP 라이브러리의 통지를 받아 초기화가 필요한 흐름 항목을 삭제</li>
<li>LACP 데이터 단위 이외의 패킷은 종래대로 학습 · 전송</li>
</ul>
<p>LACP 라이브러리 및 스위칭 허브 소스 코드는 Ryu 소스 트리에
있습니다.</p>
<blockquote>
<div><p>ryu/lib/lacplib.py</p>
<p>ryu/app/simple_switch_lacp.py</p>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">simple_switch_lacp.py는 OpenFlow 1.0 전용 응용 프로그램
이기 때문에 이 장에서는 「 <a class="reference internal" href="#ryu">Ryu 응용 프로그램의 실행</a> 」으로 보여 주었다
OpenFlow 1.3에 대응 한 simple_switch_lacp_13.py 기반으로 응용 프로그램
자세한 내용을 설명합니다.</p>
</div>
<div class="section" id="lacp">
<h3>LACP 라이브러리 구현<a class="headerlink" href="#lacp" title="제목 주소">¶</a></h3>
<p>다음 절에서는 위의 기능이 LACP 라이브러리에서 어떻게 구현되어
누가보고갑니다. 또한 인용 된 소스는 발췌입니다. 전체 그림에 대해서는 실
때 소스를 참조하십시오.</p>
<div class="section" id="id9">
<h4>논리적 인터페이스 작성<a class="headerlink" href="#id9" title="제목 주소">¶</a></h4>
<p>링크 통합 기능을 사용하려면 어떤 네트워크
기기에서 어떤 인터페이스를 어떤 그룹으로 묶을 것인가하는 설정을 일
전에 가서해야합니다. LACP 라이브러리는 다음과 같은 방법으로이 설정을
합니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dpid</span><span class="p">,</span> <span class="n">ports</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ports</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ports</span><span class="p">)</span>
    <span class="n">ifs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">port</span> <span class="ow">in</span> <span class="n">ports</span><span class="p">:</span>
        <span class="n">ifs</span><span class="p">[</span><span class="n">port</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;enabled&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&#39;timeout&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">bond</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">bond</span><span class="p">[</span><span class="n">dpid</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
</pre></div>
</div>
<p>인수의 내용은 다음과 같습니다.</p>
<p>dpid</p>
<blockquote>
<div>OpenFlow 스위치의 데이터 경로 ID를 지정합니다.</div></blockquote>
<p>ports</p>
<blockquote>
<div>그룹화 할 포트 번호 목록을 지정합니다.</div></blockquote>
<p>이 메서드를 호출하여 LACP 라이브러리는 지정된 데이터 경로 ID의
OpenFlow 스위치의 지정된 포트를 하나의 그룹으로 간주합니다.
여러 그룹을 만들려면 반복 add() 메서드를 호출
있습니다. 또한 논리적 인터페이스에 할당 된 MAC 주소는 OpenFlow
스위치가 가지는 LOCAL 포트와 동일하게 자동으로 사용됩니다.</p>
<div class="admonition tip">
<p class="first admonition-title">참고</p>
<p class="last">OpenFlow 스위치에 스위치 자신의 기능으로 링크 통합
기능을 제공하는 것도 있습니다 (Open vSwitch 등). 여기에서는 그러한
스위치 자체의 기능은 사용하지 않고, OpenFlow 컨트롤러의 제어에 의해
링크 통합 기능을 제공합니다.</p>
</div>
</div>
<div class="section" id="packet-in">
<h4>Packet-In처리<a class="headerlink" href="#packet-in" title="제목 주소">¶</a></h4>
<p>「 <a class="reference internal" href="switching_hub.html#ch-switching-hub"><em>스위칭 허브</em></a> 」은 대상의 MAC 주소가 미 학
학습의 경우 수신 된 패킷을 쇄도합니다. LACP 데이터 유닛은 인접해야
る 네트워크 장비간에 만 교환되어야하며, 다른 기기에 전송 해 버리면 리
잉크 어 그리 게이션 기능이 제대로 작동하지 않습니다. 그래서 &#8220;Packet-In 수신
패킷이 LACP 데이터 유닛이라면 차단하고 LACP 데이터 유닛
이외의 패킷이면 스위칭 허브의 동작에 맡긴다 &#8216;라는 처리를 실시해,
스위칭 허브는 LACP 데이터 단위를 보이지 않게합니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;PacketIn event handler. when the received packet was LACP,</span>
<span class="sd">    proceed it. otherwise, send a event.&quot;&quot;&quot;</span>
    <span class="n">req_pkt</span> <span class="o">=</span> <span class="n">packet</span><span class="o">.</span><span class="n">Packet</span><span class="p">(</span><span class="n">evt</span><span class="o">.</span><span class="n">msg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slow</span><span class="o">.</span><span class="n">lacp</span> <span class="ow">in</span> <span class="n">req_pkt</span><span class="p">:</span>
        <span class="p">(</span><span class="n">req_lacp</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">req_pkt</span><span class="o">.</span><span class="n">get_protocols</span><span class="p">(</span><span class="n">slow</span><span class="o">.</span><span class="n">lacp</span><span class="p">)</span>
        <span class="p">(</span><span class="n">req_eth</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">req_pkt</span><span class="o">.</span><span class="n">get_protocols</span><span class="p">(</span><span class="n">ethernet</span><span class="o">.</span><span class="n">ethernet</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_lacp</span><span class="p">(</span><span class="n">req_lacp</span><span class="p">,</span> <span class="n">req_eth</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">evt</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_event_to_observers</span><span class="p">(</span><span class="n">EventPacketIn</span><span class="p">(</span><span class="n">evt</span><span class="o">.</span><span class="n">msg</span><span class="p">))</span>
</pre></div>
</div>
<p>이벤트 처리기 자체는 「 <a class="reference internal" href="switching_hub.html#ch-switching-hub"><em>스위칭 허브</em></a> 」이라고 같습니다. 받은 메시
사지에 LACP 데이터 유닛이 포함되어 있는지 여부에 처리를 분기시키고 있습니다.</p>
<p>LACP 데이터 단위가 포함 된 경우 LACP 라이브러리 LACP 데이터 단위 접수
신호 처리합니다. LACP 데이터 단위가 포함되지 않은 경우
send_event_to_observers()라는 메서드를 부르고 있습니다. 이것은
ryu.base.app_manager.RyuApp 클래스에 정의 된 이벤트를 전송하기 위해
방법입니다.</p>
<p>「 <a class="reference internal" href="switching_hub.html#ch-switching-hub"><em>스위칭 허브</em></a> 」는 Ryu에 정의 된 OpenFlow 메시지 수신 ㄱ
벤트에 대해 언급했지만, 사용자가 직접 이벤트를 정의 할 수 있습니다.
위 소스에서 보내는 <tt class="docutils literal"><span class="pre">EventPacketIn</span></tt> 라는 이벤트는 LACP 라이브러리
리에서 만든 사용자 정의 이벤트입니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">EventPacketIn</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">EventBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;a PacketIn event class using except LACP.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialization.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EventPacketIn</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>
</pre></div>
</div>
<p>사용자 정의 이벤트는 ryu.controller.event.EventBase 클래스를 상속하여 만든
합니다. 이벤트 클래스에 내포하는 데이터에 제한은 없습니다. <tt class="docutils literal"><span class="pre">EventPacketIn</span></tt>
클래스는 Packet-In 메시지받은 ryu.ofproto.OFPPacketIn 인스턴스
스를 그대로 사용하고 있습니다.</p>
<p>사용자 정의 이벤트를 수신하는 방법에 대해서는 후술합니다.</p>
</div>
<div class="section" id="id10">
<h4>포트를 활성화 / 비활성화 상태 변경에 따른 처리<a class="headerlink" href="#id10" title="제목 주소">¶</a></h4>
<p>LACP 라이브러리 LACP 데이터 유닛 수신 처리는 다음 작업으로 구성되어 있습니다.</p>
<ol class="arabic simple">
<li>LACP 데이터 단위를받은 포트가 비활성화 상태라면 활성화 상태로 변경
하고 상태가 변경되었음을 이벤트 통지합니다.</li>
<li>비활성 시간 초과 대기 시간이 변경된 경우 LACP 데이터 단위받을 때
Packet-In을 보낼 흐름 항목을 다시 등록합니다.</li>
<li>받은 LACP 데이터 단위에 대한 응답을 작성하고 보냅니다.</li>
</ol>
<p>2. 처리 내용은 아래의
「 <a class="reference internal" href="#lacp-packet-in">LACP 데이터 단위 Packet-In시키는 흐름 항목의 등록</a> 」
그리고, 3.의 처리 내용은 아래의
「 <a class="reference internal" href="#id11">LACP 데이터 단위의 송수신 처리</a> 」
로 각각 설명합니다. 여기에서는 1.의 처리에 대해 설명합니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_do_lacp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">req_lacp</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="c"># when LACP arrived at disabled port, update the status of</span>
    <span class="c"># the slave i/f to enabled, and send a event.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slave_enabled</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s">&quot;SW=</span><span class="si">%s</span><span class="s"> PORT=</span><span class="si">%d</span><span class="s"> the slave i/f has just been up.&quot;</span><span class="p">,</span>
            <span class="n">dpid_to_str</span><span class="p">(</span><span class="n">dpid</span><span class="p">),</span> <span class="n">port</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_slave_enabled</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_event_to_observers</span><span class="p">(</span>
            <span class="n">EventSlaveStateChanged</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>
</pre></div>
</div>
<p>_get_slave_enabled () 메서드는 지정된 스위치의 지정된 포트가 유효한지 여부
하나를 가져옵니다. _set_slave_enabled () 메서드는 지정된 스위치의 지정된
포트를 활성화 / 비활성화 상태를 설정합니다.</p>
<p>위의 소스에서 비활성 상태의 포트에서 LACP 데이터 유닛을받은 경우 포트
상태가 변경되었다는 것을 나타내는 <tt class="docutils literal"><span class="pre">EventSlaveStateChanged</span></tt> 라는 사용자
정의 이벤트를 전송합니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">EventSlaveStateChanged</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">EventBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;a event class that notifies the changes of the statuses of the</span>
<span class="sd">    slave i/fs.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">enabled</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialization.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EventSlaveStateChanged</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datapath</span> <span class="o">=</span> <span class="n">datapath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">enabled</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">EventSlaveStateChanged</span></tt> 이벤트는 포트가 활성화되었을 때 다른 포트
이 비활성화 된 경우에도 전송됩니다. 비활성화했을 때의 처리는
「 <a class="reference internal" href="#flowremoved">FlowRemoved 메시지의 수신 처리</a> 」으로 구현되어 있습니다.</p>
<p><tt class="docutils literal"><span class="pre">EventSlaveStateChanged</span></tt> 클래스에는 다음 정보가 포함됩니다.</p>
<ul class="simple">
<li>포트를 활성화 / 비활성화 상태 변경이 발생한 OpenFlow 스위치</li>
<li>활성화 / 비활성화 상태 변경이 발생한 포트 번호</li>
<li>변경 후 상태</li>
</ul>
</div>
<div class="section" id="lacp-packet-in">
<h4>LACP 데이터 단위 Packet-In시키는 흐름 항목의 등록<a class="headerlink" href="#lacp-packet-in" title="제목 주소">¶</a></h4>
<p>LACP 데이터 유닛의 교환주기는 FAST (초당)와 SLOW (30 초마다)의 2 종류
가 정의되어 있습니다. 링크 통합의 사양에서는 교환주기의 3 배의 시간 무 통
신호 상태가 계속 된 경우, 그 인터페이스는 링크 집계 그룹
에서 제외 된 패킷의 전송에 사용되지 않습니다.</p>
<p>LACP 라이브러리는 LACP 데이터 단위받을 때 Packet-In시키는 흐름 항목
반면 교환주기의 3 배의 시간 (SHORT_TIMEOUT_TIME는 3 초, LONG_TIMEOUT_TIME는
90 초)을 idle_timeout로 설정하여 비활성 모니터링을 실시하고 있습니다.</p>
<p>교환주기가 변경된 경우 idle_timeout 시간도 다시 설정해야하므로
LACP 라이브러리는 다음과 같은 구현을하고 있습니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_do_lacp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">req_lacp</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="c"># set the idle_timeout time using the actor state of the</span>
    <span class="c"># received packet.</span>
    <span class="k">if</span> <span class="n">req_lacp</span><span class="o">.</span><span class="n">LACP_STATE_SHORT_TIMEOUT</span> <span class="o">==</span> \
       <span class="n">req_lacp</span><span class="o">.</span><span class="n">actor_state_timeout</span><span class="p">:</span>
        <span class="n">idle_timeout</span> <span class="o">=</span> <span class="n">req_lacp</span><span class="o">.</span><span class="n">SHORT_TIMEOUT_TIME</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idle_timeout</span> <span class="o">=</span> <span class="n">req_lacp</span><span class="o">.</span><span class="n">LONG_TIMEOUT_TIME</span>

    <span class="c"># when the timeout time has changed, update the timeout time of</span>
    <span class="c"># the slave i/f and re-enter a flow entry for the packet from</span>
    <span class="c"># the slave i/f with idle_timeout.</span>
    <span class="k">if</span> <span class="n">idle_timeout</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slave_timeout</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s">&quot;SW=</span><span class="si">%s</span><span class="s"> PORT=</span><span class="si">%d</span><span class="s"> the timeout time has changed.&quot;</span><span class="p">,</span>
            <span class="n">dpid_to_str</span><span class="p">(</span><span class="n">dpid</span><span class="p">),</span> <span class="n">port</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_slave_timeout</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">idle_timeout</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_flow</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_VERSION</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">func</span>
        <span class="n">func</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">idle_timeout</span><span class="p">,</span> <span class="n">datapath</span><span class="p">)</span>

    <span class="c"># ...</span>
</pre></div>
</div>
<p>_get_slave_timeout () 메서드는 지정된 스위치의 지정된 포트의 현
재의 idle_timeout 값을 가져옵니다. _set_slave_timeout () 메서드는 지정된 스
스위치의 지정된 포트에서 idle_timeout 값을 등록합니다. 초기 상태 및
링크 통합 그룹에서 제외 된 경우에는 idle_timeout 값은 0
설정되어 있기 때문에 새로운 LACP 데이터 유닛을받은 경우 교환주기가 어느
심지어 흐름 항목을 등록합니다.</p>
<p>사용하는 OpenFlow 버전에 따라 <tt class="docutils literal"><span class="pre">OFPFlowMod</span></tt> 클래스의 생성자
인수가 다르기 때문에 버전에 따라 유동 항목 등록 방법을 스크리닝
입니다. 다음은 OpenFlow 1.2 이상에서 사용할 흐름 항목 등록 방법입니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_add_flow_v1_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">datapath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;enter a flow entry for the packet from the slave i/f</span>
<span class="sd">    with idle_timeout. for OpenFlow ver1.2 and ver1.3.&quot;&quot;&quot;</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">OFPMatch</span><span class="p">(</span>
        <span class="n">in_port</span><span class="o">=</span><span class="n">port</span><span class="p">,</span> <span class="n">eth_src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">eth_type</span><span class="o">=</span><span class="n">ether</span><span class="o">.</span><span class="n">ETH_TYPE_SLOW</span><span class="p">)</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span>
        <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_CONTROLLER</span><span class="p">,</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPCML_MAX</span><span class="p">)]</span>
    <span class="n">inst</span> <span class="o">=</span> <span class="p">[</span><span class="n">parser</span><span class="o">.</span><span class="n">OFPInstructionActions</span><span class="p">(</span>
        <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPIT_APPLY_ACTIONS</span><span class="p">,</span> <span class="n">actions</span><span class="p">)]</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">OFPFlowMod</span><span class="p">(</span>
        <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">command</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFC_ADD</span><span class="p">,</span>
        <span class="n">idle_timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">65535</span><span class="p">,</span>
        <span class="n">flags</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFF_SEND_FLOW_REM</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">,</span>
        <span class="n">instructions</span><span class="o">=</span><span class="n">inst</span><span class="p">)</span>
    <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
</pre></div>
</div>
<p>위 소스에서 「대향 인터페이스에서 LACP 데이터 유닛을받은 경우
Packet-In한다」라고하는 흐름 항목을 비활성 감시 시간 월 최고 우선 순위로 설정
하고 있습니다.</p>
</div>
<div class="section" id="id11">
<h4>LACP 데이터 단위의 송수신 처리<a class="headerlink" href="#id11" title="제목 주소">¶</a></h4>
<p>LACP 데이터 단위받을 때 「 <a class="reference internal" href="#id10">포트를 활성화 / 비활성화 상태 변경에 따른 처리</a> 」또는
「 <a class="reference internal" href="#lacp-packet-in">LACP 데이터 단위 Packet-In시키는 흐름 항목의 등록</a> 」을 실시했다
후 응답에 대한 LACP 데이터 단위를 만들고 보냅니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_do_lacp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">req_lacp</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="c"># create a response packet.</span>
    <span class="n">res_pkt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_response</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">req_lacp</span><span class="p">)</span>

    <span class="c"># packet-out the response packet.</span>
    <span class="n">out_port</span> <span class="o">=</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_IN_PORT</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span><span class="n">parser</span><span class="o">.</span><span class="n">OFPActionOutput</span><span class="p">(</span><span class="n">out_port</span><span class="p">)]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPPacketOut</span><span class="p">(</span>
        <span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span> <span class="n">buffer_id</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_NO_BUFFER</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="n">res_pkt</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">in_port</span><span class="o">=</span><span class="n">port</span><span class="p">,</span> <span class="n">actions</span><span class="o">=</span><span class="n">actions</span><span class="p">)</span>
    <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>위 소스에서 호출되는 _create_response () 메서드는 응답 용 패킷 만들기
처리입니다. 그 중에 호출되는 _create_lacp () 메서드 응답에 대한 LACP 데이
타 유닛을 만들고 있습니다. 작성한 응답 용 패킷은 LACP 데이터 단위
수신 포트에서 Packet-Out시킵니다.</p>
<p>LACP 데이터 단위에는 전송 (Actor)의 정보와 수신자 (Partner)의 정보를 설정
합니다. 받은 LACP 데이터 단위 보내는 정보에는 대향 인터페이스 정보
가 기재되어 있으므로, OpenFlow 스위치에서 응답을 돌려 줄 때 그것을받는 정보
로 설정합니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_create_lacp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">req</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;create a LACP packet.&quot;&quot;&quot;</span>
    <span class="n">actor_system</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ports</span><span class="p">[</span><span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPP_LOCAL</span><span class="p">]</span><span class="o">.</span><span class="n">hw_addr</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="n">lacp</span><span class="p">(</span>
        <span class="c"># ...</span>
        <span class="n">partner_system_priority</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_system_priority</span><span class="p">,</span>
        <span class="n">partner_system</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_system</span><span class="p">,</span>
        <span class="n">partner_key</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_key</span><span class="p">,</span>
        <span class="n">partner_port_priority</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_port_priority</span><span class="p">,</span>
        <span class="n">partner_port</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_port</span><span class="p">,</span>
        <span class="n">partner_state_activity</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_state_activity</span><span class="p">,</span>
        <span class="n">partner_state_timeout</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_state_timeout</span><span class="p">,</span>
        <span class="n">partner_state_aggregation</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_state_aggregation</span><span class="p">,</span>
        <span class="n">partner_state_synchronization</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_state_synchronization</span><span class="p">,</span>
        <span class="n">partner_state_collecting</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_state_collecting</span><span class="p">,</span>
        <span class="n">partner_state_distributing</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_state_distributing</span><span class="p">,</span>
        <span class="n">partner_state_defaulted</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_state_defaulted</span><span class="p">,</span>
        <span class="n">partner_state_expired</span><span class="o">=</span><span class="n">req</span><span class="o">.</span><span class="n">actor_state_expired</span><span class="p">,</span>
        <span class="n">collector_max_delay</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;SW=</span><span class="si">%s</span><span class="s"> PORT=</span><span class="si">%d</span><span class="s"> LACP sent.&quot;</span><span class="p">,</span>
                     <span class="n">dpid_to_str</span><span class="p">(</span><span class="n">datapath</span><span class="o">.</span><span class="n">id</span><span class="p">),</span> <span class="n">port</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
</div>
<div class="section" id="flowremoved">
<h4>FlowRemoved 메시지의 수신 처리<a class="headerlink" href="#flowremoved" title="제목 주소">¶</a></h4>
<p>지정된 시간 동안 LACP 데이터 유닛의 교환이 이루어 않으면 OpenFlow 스
계약은 FlowRemoved 메시지를 OpenFlow 컨트롤러에 보냅니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">ofp_event</span><span class="o">.</span><span class="n">EventOFPFlowRemoved</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flow_removed_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;FlowRemoved event handler. when the removed flow entry was</span>
<span class="sd">    for LACP, set the status of the slave i/f to disabled, and</span>
<span class="sd">    send a event.&quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">evt</span><span class="o">.</span><span class="n">msg</span>
    <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
    <span class="n">dpid</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">id</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">match</span>
    <span class="k">if</span> <span class="n">ofproto</span><span class="o">.</span><span class="n">OFP_VERSION</span> <span class="o">==</span> <span class="n">ofproto_v1_0</span><span class="o">.</span><span class="n">OFP_VERSION</span><span class="p">:</span>
        <span class="n">port</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">in_port</span>
        <span class="n">dl_type</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">dl_type</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">port</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="s">&#39;in_port&#39;</span><span class="p">]</span>
        <span class="n">dl_type</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="s">&#39;eth_type&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ether</span><span class="o">.</span><span class="n">ETH_TYPE_SLOW</span> <span class="o">!=</span> <span class="n">dl_type</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s">&quot;SW=</span><span class="si">%s</span><span class="s"> PORT=</span><span class="si">%d</span><span class="s"> LACP exchange timeout has occurred.&quot;</span><span class="p">,</span>
        <span class="n">dpid_to_str</span><span class="p">(</span><span class="n">dpid</span><span class="p">),</span> <span class="n">port</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_set_slave_enabled</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_set_slave_timeout</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">send_event_to_observers</span><span class="p">(</span>
        <span class="n">EventSlaveStateChanged</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>
</pre></div>
</div>
<p>FlowRemoved 메시지를 수신하면 OpenFlow 컨트롤러
_set_slave_enabled() 메서드를 사용하여 포트의 비활성 상태를 설정하고
_set_slave_timeout() 메서드를 사용하여 idle_timeout 값을 0으로 설정하고
send_event_to_observers() 메서드를 사용하여 <tt class="docutils literal"><span class="pre">EventSlaveStateChanged</span></tt>
이벤트를 보냅니다.</p>
</div>
</div>
<div class="section" id="id12">
<h3>응용 프로그램 구현<a class="headerlink" href="#id12" title="제목 주소">¶</a></h3>
<p>「 <a class="reference internal" href="#ryu">Ryu 응용 프로그램의 실행</a> 」에 나와있는 OpenFlow 1.3 대응의 링크 애그리
게숀 애플리케이션 (simple_switch_lacp_13.py)와
「 <a class="reference internal" href="switching_hub.html#ch-switching-hub"><em>스위칭 허브</em></a> 」스위칭 허브의 차이를 차례로 설명
합니다.</p>
<div class="section" id="contexts">
<h4>「_CONTEXTS」 설정<a class="headerlink" href="#contexts" title="제목 주소">¶</a></h4>
<p>ryu.base.app_manager.RyuApp을 계승 한 Ryu 응용 프로그램은 「_CONTEXTS」
사전에 다른 Ryu 응용 프로그램을 설정하여 다른 응용
프로그램을 별도의 스레드에서 실행시킬 수 있습니다. 여기에서는 LACP 라이브러리
LacpLib 클래스를 「lacplib」라는 이름으로 「_CONTEXTS」로 설정합니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">ryu.lib</span> <span class="kn">import</span> <span class="n">lacplib</span>

<span class="c"># ...</span>

<span class="k">class</span> <span class="nc">SimpleSwitchLacp13</span><span class="p">(</span><span class="n">app_manager</span><span class="o">.</span><span class="n">RyuApp</span><span class="p">):</span>
    <span class="n">OFP_VERSIONS</span> <span class="o">=</span> <span class="p">[</span><span class="n">ofproto_v1_3</span><span class="o">.</span><span class="n">OFP_VERSION</span><span class="p">]</span>
    <span class="n">_CONTEXTS</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;lacplib&#39;</span><span class="p">:</span> <span class="n">lacplib</span><span class="o">.</span><span class="n">LacpLib</span><span class="p">}</span>

    <span class="c"># ...</span>
</pre></div>
</div>
<p>「_CONTEXTS」로 설정 한 응용 프로그램은 __init__() 메서드 kwargs에서
인스턴스를 얻을 수 있습니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="c"># ...</span>
<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">SimpleSwitchLacp13</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_lacp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;lacplib&#39;</span><span class="p">]</span>
<span class="c"># ...</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h4>라이브러리의 기본<a class="headerlink" href="#id13" title="제목 주소">¶</a></h4>
<p>「_CONTEXTS」로 설정하여 LACP 라이브러리의 초기 구성을 수행합니다. 초기 설정은
LACP 라이브러리가 제공하는 add() 메소드를 실행합니다. 여기에 다음 값을 설정
있습니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="44%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">매개변수</th>
<th class="head">값</th>
<th class="head">설명</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>dpid</td>
<td>str_to_dpid(&#8216;0000000000000001&#8217;)</td>
<td>데이터 경로 ID</td>
</tr>
<tr class="row-odd"><td>ports</td>
<td>[1, 2]</td>
<td>그룹화하는 포트 목록</td>
</tr>
</tbody>
</table>
<p>이 설정은 데이터 경로 ID「0000000000000001」의 OpenFlow 스위치의 포트1과
포트 2가 하나의 링크 통합 그룹으로 작동합니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre># ...
    self._lacp = kwargs[&#39;lacplib&#39;]
    self._lacp.add(
        dpid=str_to_dpid(&#39;0000000000000001&#39;), ports=[1, 2])
# ...
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h4>사용자 정의 이벤트를 수신하는 방법<a class="headerlink" href="#id14" title="제목 주소">¶</a></h4>
<p><a class="reference internal" href="#lacp">LACP 라이브러리 구현</a> 에서 설명한대로 LACP 라이브러리는 LACP 데이터 유닛
트가 포함되지 않은 Packet-In 메시지를 <tt class="docutils literal"><span class="pre">EventPacketIn</span></tt> 라는 사용자 정의
이벤트로 보냅니다. 사용자 정의 이벤트의 이벤트 처리기도 Ryu 제공합니다
이벤트 처리기처럼 <tt class="docutils literal"><span class="pre">ryu.controller.handler.set_ev_cls</span></tt> 데코
레이터로 장식합니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">lacplib</span><span class="o">.</span><span class="n">EventPacketIn</span><span class="p">,</span> <span class="n">MAIN_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_packet_in_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">msg</span>
    <span class="n">datapath</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">datapath</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>
    <span class="n">in_port</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">match</span><span class="p">[</span><span class="s">&#39;in_port&#39;</span><span class="p">]</span>

    <span class="c"># ...</span>
</pre></div>
</div>
<p>또한 LACP 라이브러리는 포트를 활성화 / 비활성화 상태가 변경되면
<tt class="docutils literal"><span class="pre">EventSlaveStateChanged</span></tt> 이벤트를 송신하기 때문에, 이쪽도 이벤트 핸드
라를 만들어 둡니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="nd">@set_ev_cls</span><span class="p">(</span><span class="n">lacplib</span><span class="o">.</span><span class="n">EventSlaveStateChanged</span><span class="p">,</span> <span class="n">lacplib</span><span class="o">.</span><span class="n">LAG_EV_DISPATCHER</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_slave_state_changed_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ev</span><span class="p">):</span>
    <span class="n">datapath</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">datapath</span>
    <span class="n">dpid</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">id</span>
    <span class="n">port_no</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">port</span>
    <span class="n">enabled</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">enabled</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;slave state changed port: </span><span class="si">%d</span><span class="s"> enabled: </span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span>
                     <span class="n">port_no</span><span class="p">,</span> <span class="n">enabled</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dpid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">mac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">]:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span><span class="o">.</span><span class="n">OFPMatch</span><span class="p">(</span><span class="n">eth_dst</span><span class="o">=</span><span class="n">mac</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">del_flow</span><span class="p">(</span><span class="n">datapath</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="p">[</span><span class="n">dpid</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mac_to_port</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">dpid</span><span class="p">,</span> <span class="p">{})</span>
</pre></div>
</div>
<p>이 절의 시작 부분에서 설명한대로 포트를 활성화 / 비활성화 상태가 변경됩니다
논리적 인터페이스를 통
오버 패킷이 실제로 사용하는 물리적 인터페이스가 변경 될 가능성이있어
입니다. 따라서 등록 된 흐름 항목을 모두 삭제
하고 있습니다.</p>
<div class="sourcecode highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">del_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapath</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="n">ofproto</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">datapath</span><span class="o">.</span><span class="n">ofproto_parser</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">OFPFlowMod</span><span class="p">(</span><span class="n">datapath</span><span class="o">=</span><span class="n">datapath</span><span class="p">,</span>
                            <span class="n">command</span><span class="o">=</span><span class="n">ofproto</span><span class="o">.</span><span class="n">OFPFC_DELETE</span><span class="p">,</span>
                            <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">)</span>
    <span class="n">datapath</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
</pre></div>
</div>
<p>흐름 항목의 삭제는 <tt class="docutils literal"><span class="pre">OFPFlowMod</span></tt> 클래스의 인스턴스로합니다.</p>
<p>이상과 같이, 링크 통합 기능을 제공하는 라이브러리와 라이브러리
를 사용하는 응용 프로그램에서 링크 어 그리 게이션 기능을 가진 스위칭
허브 응용 프로그램을 실현하고 있습니다.</p>
</div>
</div>
</div>
<div class="section" id="id15">
<h2>정리<a class="headerlink" href="#id15" title="제목 주소">¶</a></h2>
<p>이 장에서는 링크 통합 라이브러리 사용을 주제로 다음 항목
대해 설명했습니다.</p>
<ul class="simple">
<li>「_CONTEXTS」을 이용한 라이브러리 사용 방법</li>
<li>사용자 정의 이벤트를 정의하는 방법과 이벤트 트리거의 발생 방법</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">링크 어그리게이션</a><ul>
<li><a class="reference internal" href="#id2">링크 어그리게이션</a></li>
<li><a class="reference internal" href="#ryu">Ryu 응용 프로그램의 실행</a><ul>
<li><a class="reference internal" href="#id3">실험 환경 구축</a></li>
<li><a class="reference internal" href="#h1">호스트 h1에서 링크 통합 구성</a></li>
<li><a class="reference internal" href="#openflow">OpenFlow 버전 설정</a></li>
<li><a class="reference internal" href="#id4">스위칭 허브의 실행</a></li>
<li><a class="reference internal" href="#id5">링크 통합 기능 확인</a><ul>
<li><a class="reference internal" href="#id6">통신 속도 향상</a></li>
<li><a class="reference internal" href="#id7">결함 허용 향상</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id8">Ryu의 링크 애그리 게이션 기능의 구현</a><ul>
<li><a class="reference internal" href="#lacp">LACP 라이브러리 구현</a><ul>
<li><a class="reference internal" href="#id9">논리적 인터페이스 작성</a></li>
<li><a class="reference internal" href="#packet-in">Packet-In처리</a></li>
<li><a class="reference internal" href="#id10">포트를 활성화 / 비활성화 상태 변경에 따른 처리</a></li>
<li><a class="reference internal" href="#lacp-packet-in">LACP 데이터 단위 Packet-In시키는 흐름 항목의 등록</a></li>
<li><a class="reference internal" href="#id11">LACP 데이터 단위의 송수신 처리</a></li>
<li><a class="reference internal" href="#flowremoved">FlowRemoved 메시지의 수신 처리</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">응용 프로그램 구현</a><ul>
<li><a class="reference internal" href="#contexts">「_CONTEXTS」 설정</a></li>
<li><a class="reference internal" href="#id13">라이브러리의 기본</a></li>
<li><a class="reference internal" href="#id14">사용자 정의 이벤트를 수신하는 방법</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id15">정리</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="rest_api.html"
                        title="이전 장">REST연계</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="spanning_tree.html"
                        title="다음 장">스패닝 트리</a></p>
  <h3>현재 문서</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/link_aggregation.txt"
           rel="nofollow">소스 코드를 보려면</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>빠른 검색</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="바로 가기" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    모듈, 클래스 또는 함수 이름을 입력하십시오.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="spanning_tree.html" title="스패닝 트리"
             >다음</a> |</li>
        <li class="right" >
          <a href="rest_api.html" title="REST연계"
             >이전</a> |</li>
        <li><a href="index.html">Ryubook 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, RYU project team.
    </div>
  </body>
</html>